/**
 * generated by Xtext 2.31.0
 */
package org.xtext.project.cw.validation;

import com.google.common.collect.Sets;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IntegerRange;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.xtext.project.cw.myDsl.Attribute;
import org.xtext.project.cw.myDsl.Entity;
import org.xtext.project.cw.myDsl.Model;
import org.xtext.project.cw.myDsl.MyDslPackage;
import org.xtext.project.cw.myDsl.Screen;
import org.xtext.project.cw.myDsl.Trigger;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MyDslValidator extends AbstractMyDslValidator {
  @Check
  public void checkAttributeNameStartWithLowercaseCharacter(final Attribute attr) {
    boolean _isLowerCase = Character.isLowerCase(attr.getName().charAt(0));
    boolean _not = (!_isLowerCase);
    if (_not) {
      this.warning("Attribute should start with lower-case letter", attr, MyDslPackage.Literals.ATTRIBUTE__NAME);
    }
  }

  @Check
  public void checkScreenNameStartWithLowercaseCharacter(final Screen scr) {
    boolean _isLowerCase = Character.isLowerCase(scr.getName().charAt(0));
    boolean _not = (!_isLowerCase);
    if (_not) {
      this.warning("Screen name should start with lower-case letter", scr, MyDslPackage.Literals.SCREEN__NAME);
    }
  }

  @Check
  public void checkScreenNameStartWithLowercaseCharacter(final Entity ent) {
    boolean _isLowerCase = Character.isLowerCase(ent.getName().charAt(0));
    boolean _not = (!_isLowerCase);
    if (_not) {
      this.warning("Screen name should start with lower-case letter", ent, MyDslPackage.Literals.ENTITY__NAME);
    }
  }

  @Check
  public void checkSameNameScreen(final Model model) {
    final Function1<Screen, String> _function = (Screen it) -> {
      return it.getName();
    };
    long _count = ListExtensions.<Screen, String>map(model.getScreens(), _function).stream().distinct().count();
    final Function1<Screen, String> _function_1 = (Screen it) -> {
      return it.getName();
    };
    int _size = ListExtensions.<Screen, String>map(model.getScreens(), _function_1).size();
    boolean _lessThan = (_count < _size);
    if (_lessThan) {
      this.error("Screen names should be unique", model, MyDslPackage.Literals.MODEL__SCREENS);
    }
  }

  @Check
  public void checkSameNameEntity(final Model model) {
    final Function1<Entity, String> _function = (Entity it) -> {
      return it.getName();
    };
    long _count = ListExtensions.<Entity, String>map(model.getEntities(), _function).stream().distinct().count();
    final Function1<Entity, String> _function_1 = (Entity it) -> {
      return it.getName();
    };
    int _size = ListExtensions.<Entity, String>map(model.getEntities(), _function_1).size();
    boolean _lessThan = (_count < _size);
    if (_lessThan) {
      this.error("Screen names should be unique", model, MyDslPackage.Literals.MODEL__ENTITIES);
    }
  }

  @Check
  public void checkSameNameAnywhere(final Model model) {
    EList<Entity> entity = model.getEntities();
    EList<Screen> screen = model.getScreens();
    int _size = this.listEntityScreenDif(entity, screen).size();
    int _size_1 = entity.size();
    boolean _lessThan = (_size < _size_1);
    if (_lessThan) {
      this.error("Variable Names should be unique", model, MyDslPackage.Literals.MODEL__ENTITIES);
      this.error("Variable Names should be unique", model, MyDslPackage.Literals.MODEL__SCREENS);
    }
  }

  public ArrayList<String> listEntityScreenDif(final List<Entity> list, final List<Screen> list2) {
    final Function1<Entity, String> _function = (Entity it) -> {
      return it.getName();
    };
    List<String> _map = ListExtensions.<Entity, String>map(list, _function);
    HashSet<String> newList1 = new HashSet<String>(_map);
    final Function1<Screen, String> _function_1 = (Screen it) -> {
      return it.getName();
    };
    List<String> _map_1 = ListExtensions.<Screen, String>map(list2, _function_1);
    HashSet<String> newList2 = new HashSet<String>(_map_1);
    Sets.SetView<String> _difference = Sets.<String>difference(newList1, newList2);
    ArrayList<String> finalList = new ArrayList<String>(_difference);
    return finalList;
  }

  @Check(CheckType.NORMAL)
  public void checkCanReachAllScreen(final Model model) {
    final List<Screen> screensNotReachable = this.allNotReachable(model.getScreens());
    int _size = screensNotReachable.size();
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      int _size_1 = screensNotReachable.size();
      int _minus = (_size_1 - 1);
      final Consumer<Integer> _function = (Integer i) -> {
        this.warning("Screen not reachable", screensNotReachable.get((i).intValue()), MyDslPackage.Literals.SCREEN__NAME);
      };
      new IntegerRange(0, _minus).forEach(_function);
    }
  }

  private List<Screen> allNotReachable(final List<Screen> screens) {
    List<Screen> _xblockexpression = null;
    {
      final Function1<Screen, List<Screen>> _function = (Screen it) -> {
        return this.screenReached(it);
      };
      List<Screen> reachableScreens = IterableExtensions.<Screen>toList(IterableExtensions.<Screen, Screen>flatMap(screens, _function));
      _xblockexpression = this.listScreenDifference(screens, reachableScreens);
    }
    return _xblockexpression;
  }

  private List<Screen> screenReached(final Screen screen) {
    final Function1<Trigger, Screen> _function = (Trigger it) -> {
      return this.getScreensReachable(it);
    };
    return ListExtensions.<Trigger, Screen>map(screen.getTriggers(), _function);
  }

  private Screen getScreensReachable(final Trigger tr) {
    return tr.getScreen();
  }

  public List<Screen> listScreenDifference(final List<Screen> list1, final List<Screen> list2) {
    HashSet<Screen> newList1 = new HashSet<Screen>(list1);
    HashSet<Screen> newList2 = new HashSet<Screen>(list2);
    Sets.SetView<Screen> _difference = Sets.<Screen>difference(newList1, newList2);
    ArrayList<Screen> finalList = new ArrayList<Screen>(_difference);
    return finalList;
  }
}
