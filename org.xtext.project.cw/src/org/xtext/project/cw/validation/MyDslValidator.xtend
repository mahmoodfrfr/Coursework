/*
 * generated by Xtext 2.31.0
 */
package org.xtext.project.cw.validation;

import org.eclipse.xtext.validation.Check;
import org.xtext.project.cw.myDsl.Attribute;
import org.xtext.project.cw.myDsl.MyDslPackage
import org.xtext.project.cw.myDsl.Model
import java.util.List
import org.xtext.project.cw.myDsl.Screen
import org.xtext.project.cw.myDsl.Trigger
import org.xtext.project.cw.myDsl.Entity
import java.util.HashSet
import com.google.common.collect.Sets
import java.util.ArrayList

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MyDslValidator extends AbstractMyDslValidator {
	

	@Check
	def checkAttributeNameStartWithLowercaseCharacter(Attribute attr) {
		if (!Character.isLowerCase(attr.name.charAt(0))) {
			warning('Attribute should start with lower-case letter',attr,MyDslPackage.Literals.ATTRIBUTE__NAME);
		}
	}
	
	@Check
	def checkScreenNameStartWithLowercaseCharacter(Screen scr) {
		if (!Character.isLowerCase(scr.name.charAt(0))) {
			warning('Screen name should start with lower-case letter',scr,MyDslPackage.Literals.SCREEN__NAME);
		}
	}
	
	@Check
	def checkScreenNameStartWithLowercaseCharacter(Entity ent) {
		if (!Character.isLowerCase(ent.name.charAt(0))) {
			warning('Screen name should start with lower-case letter',ent,MyDslPackage.Literals.ENTITY__NAME);
		}
	}
	
	@Check
	def checkSameNameScreen(Model model){
		if(model.screens.map[getName].stream.distinct.count < model.screens.map[getName].size){
			error('Screen names should be unique',model,MyDslPackage.Literals.MODEL__SCREENS);
		}
	}
	
	
	@Check
	def checkSameNameEntity(Model model){
		if(model.entities.map[getName].stream.distinct.count < model.entities.map[getName].size){
			error('Screen names should be unique',model,MyDslPackage.Literals.MODEL__ENTITIES);
		}
	}
	
	@Check
	def checkSameNameAnywhere(Model model){
		var entity = model.entities
		var screen = model.screens
		if(listEntityScreenDif(entity,screen).size < entity.size){
			error('Variable Names should be unique',model,MyDslPackage.Literals.MODEL__ENTITIES);
			error('Variable Names should be unique',model,MyDslPackage.Literals.MODEL__SCREENS);
		}
	}
	
	def listEntityScreenDif(List<Entity> list, List<Screen> list2) {
		var newList1 = new HashSet<String>(list.map[name]);
		var newList2 = new HashSet<String>(list2.map[name]);
		var finalList = new ArrayList<String>(Sets.difference(newList1,newList2))
    	return finalList;
	}
	
		
	
	@Check(NORMAL) //Allows screen to reach itself
	def checkCanReachAllScreen(Model model){
		val screensNotReachable = model.screens.allNotReachable
		if(screensNotReachable.size > 0){
			(0..screensNotReachable.size-1).forEach[i|warning('Screen not reachable',screensNotReachable.get(i),MyDslPackage.Literals.SCREEN__NAME)]
			
			  //warning('Screen not reachable',model,MyDslPackage.Literals.MODEL__SCREENS);			
		}
	}
	

	
	private def allNotReachable(List<Screen> screens){
		var reachableScreens = screens.flatMap[screenReached].toList
		listScreenDifference(screens,reachableScreens)
	}
	
	private def List<Screen> screenReached(Screen screen){
		screen.triggers.map[getScreensReachable]
	}
	
	private def Screen getScreensReachable(Trigger tr){
		tr.screen
	}
	
	def List<Screen> listScreenDifference(List<Screen> list1, List<Screen> list2) {
		var newList1 = new HashSet<Screen>(list1);
		var newList2 = new HashSet<Screen>(list2);
		var finalList = new ArrayList<Screen>(Sets.difference(newList1,newList2))
    	return finalList;
	}
	
	//private dispatch def boolean predictScreenOutcome(Screen screen,boolean pr) { }
}